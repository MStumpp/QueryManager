{"name":"QueryManager","tagline":"","body":"## Create QueryManager instance\r\n\r\nAllocate an instance of the **QueryManager** in the following way.\r\n```\r\nQueryManager *manager = [QueryManager instance];\r\n```   \r\n\r\n### Configure QueryManager instance\r\n\r\nYou may set the maximum number of concurrent connections for all queues.\r\n```\r\n[manager setNumberOfMaxConcurrentConnections:10];\r\n```   \r\n\r\n* numberMaxConcurrent: Maximum number of concurrent connections over all queues. Lowest value is 0. Use _tUnlimitedConcurrentConnections_ for unlimited number of connections. \r\n\r\n## Create Queue instance\r\n\r\nAllocate an instance of **Queue** in the following way.\r\n```\r\nQueue *queue = [manager initQueueWithPrio:1 andIdentifier:@\"queue 1\"]\r\n```\r\n* prio: Only one prio of same value per manager. Lowest value for priority is 0 (highest priority).      \r\n* identifier: A unique identifier per queue.\r\n\r\n## Get Queue instance from QueryManager\r\n\r\n```\r\nQueue *queue = [manager getQueueWithIdentifier:@\"queue 1\"]\r\n```\r\n    \r\n## Create Query instance\r\n```\r\nQueryTicket *ticket = [[ConcreteQuery instanceWithQueue:queue] process:(id)data onCompletion:^(int state, id data, NSError *error) {\r\n   ...\r\n}];\r\n```\r\n\r\n## Query implementation\r\n```\r\n@interface ConcreteQuery : Query\r\n@end\r\n\r\n@implementation ConcreteQuery\r\n-(void)load:(id)data\r\n{\r\n    ... do stuff, then call\r\n    [self loadedWithData:data andError:nil];\r\n}\r\n\r\n-(void)pause:(id)data\r\n{\r\n    ... do stuff, then call\r\n    [self pausedWithData:data andError:nil];\r\n}\r\n\r\n-(void)cancel:(id)data\r\n{\r\n    ... do stuff, then call\r\n    [self cancelledWithData:data andError:nil];\r\n}\r\n@end\r\n```\r\n\r\n### Feature Candidates\r\n\r\n* queueMaxSize: Maximum size of a queue, meaning number of Query instances in state _initial_, _loading_, _pausing_ or _paused_ (Query instances in state _loaded_, _cancelling_ or _cancelled_ are not count towards this metric). Use _tUnlimitedQueueSize_ for unlimited number of Query instances. (defaults to: tUnlimitedQueueSize)\r\n```\r\n[queue setQueueMaxSize:tUnlimitedQueueSize]; \r\n```\r\n\r\n* numberMaxConcurrent: Maximum number of concurrent connections over all queues. Lowest value is 0. Use _tUnlimitedConcurrentConnections_ for unlimited number of connections. (defaults to: tUnlimitedConcurrentConnections)\r\n```\r\n[queue setNumberMaxConcurrent:tUnlimitedConcurrentConnections]; \r\n```\r\n\r\n* processOrder: Order of how Query instances will be processed. Use _tfifo_ for first in first out or _tlifo_ for last in first out. (defaults to: tfifo)\r\n```\r\n[queue setProcessOrder:tfifo]; \r\n```\r\n\r\n* finishHigherPrioFirst. (defaults to: false) \r\n```\r\n[queue setFinishHigherPrioFirst:TRUE]; \r\n```\r\n\r\n* pauseWhileLoading: Pauses all Query instances which come after the added one, from the other queues as well as the same queue. (defaults to: false)\r\n```\r\n[queue setPauseWhileLoading:TRUE]; \r\n```\r\n\r\n* cancelWhileLoading: Cancels all Query instances which come after the added one, from the other queues as well as the same queue. (defaults to: false)\r\n```\r\n[queue setCancelWhileLoading:TRUE];  \r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}